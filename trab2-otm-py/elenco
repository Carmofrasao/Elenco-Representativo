#!/usr/bin/python3

import sys
import datetime as dt

ator = {
    'valor' :   0,
    'n_grupos': 0,
    'grupos':   [],
}

# Vetor com todos os atores disponiveis
Atores_disponiveis = []

# Vetor com os atores escolhidos
Atores_escolhidos = []

otimo = []
# Numero de grupos (l = |S|)
l = 0
# Numero de atores (m = |A|)
m = 0
# Numero de personagens (n = |P|)
n = 0
# Nodos visitados na árvore
nodos = 0
# Custo total até o momento
custo_total = 1000

def custo(E):
    sum = 0

    for ator in E:
        sum += int(ator['valor'])

    return sum

# Calcula o ator mais barato
# F é o vetor ao qual vai ser escolhido o ator mais barato
# len é o espaço preenchido em F
def min(F, len):
    resul = F[0]['valor']
    index = 0
    for i in range(1, len):
        if F[i]['valor'] < resul:
            resul = F[i]['valor']
            index = i
    return index

def B_dada(E, F):
    len_F = len(F)
    len_E = len(E)

    # soma dos salario dos atores escolhidos
    result = 0

    # Somatorio dos valores dos atores que ja foram escolhidos
    for i in range(len_E):
        result += E[i]['valor']

    # indice do ator mais barato no vetor de atores disponiveis
    index_min = min(F, len_F)

    # Pega o ator mais barato, multiplica pelo numero de papeis que falta preecher
    # E soma ao valor total dos atores
    result +=  (n - len_E) * F[index_min]['valor']
    
    return result

def viavel(E, F):
    global l, m, n

    # print("escolhidos: ", E, "disponiveis: ", F)
    representados = set()
    for ator in E:
        for grupo in ator['grupos']:
            representados.add(grupo)

    # print("representados: ", representados)

    nao_representados = set()
    for ator in F:
        for grupo in ator['grupos']:
            nao_representados.add(grupo)
    
    # print("nao representados: ", nao_representados)

    if len(representados.union(nao_representados)) != l:
        print("1: ", len(representados.union(nao_representados)))
        return False

    if len(F) + len(E) < n:
        print("2: ", len(F) + len(E))
        return False

    if len(E) > n:
        print("3: ", len(F))
        return False

    return True

def elenca(E, F):
    global nodos, n, m, custo_total, otimo
    print("RODADA ", nodos)
    print("\n")
    
    for i in range(m):
        # Visitamos mais um nodo
        nodos += 1

        # Caso base 1: inviável
        if not viavel(E, F):
            F.insert(0, E.pop(len(E)-1))
            return

        # Caso base 2: se preenchemos o vetor de escolhidos e é viável
        if len(E) == n: 
            custo_local = custo(E)
            print("custo local: ",custo_local, "\n custo total: ", custo_total)
            if (custo_local < custo_total):
                custo_total = custo_local
                otimo = E.copy()
            F.insert(0, E.pop(len(E)-1))
            return
        
        E.append(F.pop(i))
        bound = B_dada(E, F)
        print("bound: ", bound)
        print("custo total: ", custo_total)

        for ator in F:

            print("escolhidos: ", E, "\n", "disponiveis: ", F)
            if (bound >= custo_total):
                F.insert(0, E.pop(len(E)-1))
                return

            F.remove(ator)
            E.append(ator)
            print("escolhidos: ", E ,"\n", "disponiveis: ", F)
            elenca(E,F)    

    


if __name__ == "__main__":
    f = o = a = 0

    # Indentificando flags para a execução do Branch & Bound
    if len(sys.argv) > 1:
        for i in range(1, len(sys.argv)):
            if sys.argv[i] == '-f':
                f = 1
            elif sys.argv[i] == '-o':
                o = 1
            elif sys.argv[i] == '-a':
                a =1
    
    # -f = desligar os cortes de viabilidade
    # -o = desligar os cortes de otimalidade
    # -a = usar a função limitante dada pelos professores

    # Lendo numero de representações, atores e papeis 
    entrada = [int(x) for x in sys.stdin.read().split()]
    l = entrada[0] # numero de grupos sociais
    m = entrada[1] # numero de atores
    n = entrada[2] # numero de personagens
    # l = |S|, m = |A| e n = |P| 

    cursor = 3

    # Dados um conjunto S de grupos, um conjunto A de atores, um conjunto
    # P de personagens, e, para cada ator a ∈ A, um conjunto, Sa ⊆ S indicando os
    # grupos dos quais a faz parte, devemos encontrar um elenco que tenha um ator
    # para cada personagem (todos os atores podem fazer todas as personagens) e
    # todos os grupos tenham um representante. Além disso, também temos um
    # valor, va, associado com cada ator a ∈ A, e queremos que o custo do elenco
    # seja mínimo.
    # Ou seja, devemos encontrar um subconjunto X ⊆ A tal que:
    # - |X| = |P|;
    # - (UNIÃO)(a∈X)Sa = S; e
    # - (SOMATÓRIO)(a∈X)va seja mínimo.

    # Lendo atores e suas caracteristicas
    for _ in range(m):
        ator['valor'] = entrada[cursor]
        ator['n_grupos'] = entrada[cursor+1]
        for i in range(ator['n_grupos']):
            ator['grupos'].append(entrada[cursor+2+i])
        cursor += ator['n_grupos']+2
        aux = ator.copy()
        Atores_disponiveis.append(aux)
        ator['grupos'] = []

    # ------------------------CODIGO PRINCIPAL AQUI-------------------------------

    tempo_inicio = dt.datetime.now()
    elenca(Atores_escolhidos, Atores_disponiveis)
    print("nodos visitados: ", nodos)
    print(otimo)
    tempo_total = dt.datetime.now() - tempo_inicio

    # ----------------------------------------------------------------------------